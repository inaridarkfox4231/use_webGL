<!DOCTYPE html>
<html>
<head>
  <title>GLSLだけでレンダリング</title>
  <!-- fragment shader -->
  <script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform float time;
    uniform vec2  mouse;
    uniform vec2  resolution;

    const float ITERATIONS = 64.0; // 繰り返し回数の上限
    const float PI = 3.14159; // 円周率

    // 中心（center, 0.0）,半径radiusの円による反転操作
    vec2 inversion(vec2 q, float radius, float center){
      float factor = pow(radius, 2.0) / (pow(q.x - center, 2.0) + pow(q.y, 2.0));
      return vec2(center, 0.0) + (vec2(q.x - center, q.y) * factor);
    }
    // 比s/rを求めるための計算
    float calc_ratio(float theta, float phi){
      return (cos(phi) + sqrt(pow(cos(phi), 2.0) - pow(sin(theta), 2.0))) / pow(sin(theta), 2.0);
    }

    // 上半平面への変換関数
    vec2 poincare_to_half(vec2 p){
      return vec2(-2.0 * p.y, (1.0 - pow(p.x, 2.0) - pow(p.y, 2.0))) / (pow(p.x - 1.0, 2.0) + pow(p.y, 2.0));
    }
    // ぎゅーんゆっくり
    float easing_2(float x){
      return 200.0 * ((7.0 / 8.0) + (x / 1600.0) - (7.0 / 8.0) * pow(1.0 - (x / 200.0), 4.0));
    }
    // ゆっくりぎゅーん
    float easing_3(float x){
      return 200.0 * ((x / 1600.0) + (7.0 / 8.0) * pow(x / 200.0, 4.0));
    }


    float reflection_3(){
      // 円の反転で遊んでみる
      // pは x:-1.0～1.0, y:-1.0～1.0 の範囲で。
      vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);
      if(!(length(p) < 1.0)){ return -1.0; } // 円の外側
      // 上半平面に変換
      p = poincare_to_half(p);
      mat2 ref0 = mat2(-1.0, 0.0, 0.0, 1.0);
      // float r = 3.1426 + 2.6426 * sin(time * PI);
      // 3回ループしたのち逆方向に動くように調整

      // rについて。0.5は最小値。最大値は、それをr'として、r * r' = (s * sin(theta))^2 で求める。
      // （ただしこの計算でrは0.5, sはrが0.5の場合の値、つまりratio * 0.5である。）
      // この場合のr'は5.785233..になるので、それを元にしてこの手の処理を算出している。

      float direction = 1.0 - mod(floor(time * 25.0 / 200.0), 2.0) * 2.0;
      float r;
      // mod(time * 50.0, 100.0)は0～100の範囲を動くので、
      float progress = mod(time * 25.0, 200.0);

      // (6,5)型。(m,n)は1/m + 1/n < 1/2という制約条件を満たす必要がある。
      // mが奇数の時は計算方法が違うのかな・・
      // あーそうか、mが奇数の場合はy軸上に3つの頂点がすべて現れるから計算の仕方が変わっちゃうのね。
      // mが奇数でnが偶数でもおかしなことになるようだ・・
      float theta = PI / 6.0;
      float phi = PI / 6.0;
      // r_minとr_maxの定義はここで行う
      float r_min = 0.5;
      float r_max = 500.0;
      float interval = (r_max - r_min) / 200.0;
      if(direction > 0.0){
        progress = easing_3(progress);
        r = r_min + interval * progress;
      }else{
        progress = easing_2(progress);
        r = r_max - interval * progress;
      }
      float ratio = calc_ratio(theta, phi);
      float s = ratio * r;
      float a = -s * cos(theta);

      float count = 0.0;
      bool b = false;
      for(float i = 0.0; i < ITERATIONS; i += 1.0){
        if(p.x < 0.0){
          p = ref0 * p;
          count += 1.0;
        }else if(length(p) < r){
          p = inversion(p, r, 0.0);
          count += 1.0;
        }else if(length(p - vec2(a, 0.0)) > s){
          p = inversion(p, s, a);
          count += 1.0;
        }else{
          b = true;
        }
        if(b){ break; }
      }
      return mod(count, 2.0);
    }

    void main(void){
      float ref = reflection_3();
      gl_FragColor = vec4(0.2 + ref * 0.3, 0.4 + ref * 0.3, 0.3 + 0.5 * ref, 1.0);
    }
  </script>
  <!-- /fragment shader -->

  <!-- vertex shader -->
  <script id="vs" type="x-shader/x-vertex">
    attribute vec3 position;

    void main(void){
      gl_Position = vec4(position, 1.0);
    }
  </script>
  <!-- /vertex shader -->

  <script src="./src/script_8.js" type="text/javascript"></script>
  <style type="text/css">
    *{
      text-align: center;
      margin: 10px auto;
      padding: 0px;
    }
    canvas{
      box-shadow: 0px 0px 0px 1px gray;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <p><input type="checkbox" id="check" checked><label for="check"> auto run</label></p>
</body>
</html>
